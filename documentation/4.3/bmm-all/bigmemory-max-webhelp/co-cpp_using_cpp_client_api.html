<!DOCTYPE html ><html xml:lang="en" lang="en" xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta http-equiv="Content-Style-Type" content="text/css"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Using the C++ Client API</title><link rel="Prev" href="co-cpp_accessing_data.html" title="Previous"><link rel="Next" href="co-cpp_client_serialization.html" title="Next"><link rel="StyleSheet" href="css/aaa_bigmem_max_all.css" type="text/css" media="all"><link rel="StyleSheet" href="css/skin.css" type="text/css" media="all"><link rel="StyleSheet" href="css/social.css" type="text/css" media="all"><link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all"><!--[if IE 7]><link rel="StyleSheet" href="css/aaa_bigmem_max_all_IE7.css" type="text/css" media="all"><![endif]--><link rel="StyleSheet" href="css/print.css" type="text/css" media="print"><script type="text/javascript">
    'use strict';

    var redirect_url, page_hash;

    if (window === window.top) {
        // Redirect
        //
        redirect_url = "../index.html#page/bigmemory-max-webhelp/co-cpp_using_cpp_client_api.html";
        if (window.document.location.hash.length > 1) {
            // Sanitize and append it
            //
            page_hash = window.document.location.hash.substring(1);
            page_hash = page_hash.replace(/[\\><:;"]|%5C|%3C|%3E|%3A|%3B|%22/gi, '');
            redirect_url += '#' + page_hash;
        }
        window.document.location.replace(redirect_url);
    }
</script><script type="text/javascript" src="scripts/common.js"></script><script type="text/javascript" src="scripts/page.js"></script><script type="text/javascript" src="scripts/search-client.js"></script><script type="text/javascript" src="scripts/unidata.js"></script><script type="text/javascript" src="scripts/unibreak.js"></script></head><body id="pnlhdzJPRyYRVvjtpNkAd2g" class="ww_skin_page_body" onload="Page.OnLoad('../index.html#page/bigmemory-max-webhelp/co-cpp_using_cpp_client_api.html');"><header id="wwconnect_header"><div class="ww_skin_breadcrumbs"><span class="ww_skin_breadcrumbs_parent"><a href="../bigmemory-max-webhelp/to-title_component_documentation.html#wwconnect_header">Component Documentation</a></span><span class="ww_skin_breadcrumbs_divider"> : </span><span class="ww_skin_breadcrumbs_parent"><a href="../bigmemory-max-webhelp/to-title_ccl_user_guide.html#wwconnect_header">Cross-Language Clients User Guide</a></span><span class="ww_skin_breadcrumbs_divider"> : </span><span class="ww_skin_breadcrumbs_parent"><a href="../bigmemory-max-webhelp/to-cpp_clients.html#wwconnect_header">BigMemory C++ Client</a></span><span class="ww_skin_breadcrumbs_divider"> : </span><span class="ww_skin_breadcrumbs_current">Using the C++ Client API</span></div><div class="ww_skin_page_toolbar"></div></header><div id="ww3_21_12_11_12_1" class="Heading_3">Using the C++ Client API</div><div id="ww3_21_12_11_12_3_2" class="Body">This section covers connecting to, working with, and searching your BigMemory data. For the complete class library documentation, refer to the API documentation in the <span class="filepath">/apis/csharp/apidoc-cpp.zip</span> directory of the kit.</div><div id="ww3_21_12_11_12_3_4_2" class="Section_Title">Connecting with the CL Connector</div><div id="ww3_21_12_11_12_3_4_4" class="Body">Your application will communicate with the CL Connector via the CacheManager interface.</div><div id="ww3_21_12_11_12_3_4_6" class="Body">Begin by creating a Configuration object. For a deployment where the BigMemory Client is located on the same machine as the CL Connector, use a configuration with the Nirvana Shared Memory (SHM) transport:</div><div id="ww3_21_12_11_12_3_4_8" class="Preformatted">Configuration("/dev/shm", 16);</div><div id="ww3_21_12_11_12_3_4_10" class="Body">For a deployment where the BigMemory Client and the CL Connector are located on different machines, use a configuration with the Nirvana socket transport. For example, here we create a configuration that connects to the local host at port 8199, and provisions a pool of 16 connections to share:</div><div id="ww3_21_12_11_12_3_4_12" class="Preformatted">Configuration("localhost", 8199, 16);</div><div id="ww3_21_12_11_12_3_4_14" class="Body">Notice that configurations with different transport types require different parameters:</div><div id="ww3_21_12_11_12_3_4_16_2_2" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="bullet.gif" alt="*" border="0" width="10" height="10"></span></span><span class="inlinetitle">Nirvana Shared Memory (SHM)</span> - <span class="parmname">Configuration("SHMLocation", clientPoolSize)</span> - generally used when the BigMemory Client is located on the same machine as the CL Connector.</div><div id="ww3_21_12_11_12_3_4_16_2_4" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="bullet.gif" alt="*" border="0" width="10" height="10"></span></span><span class="inlinetitle">Nirvana socket</span> - <span class="parmname">Configuration("hostName", portNumber, clientPoolSize)</span> - used when the CL Connector and the BigMemory Client are located on different machines.</div><div id="ww3_21_12_11_12_3_4_18" class="Body">Once you have your Configuration instance ready, create a CacheManager using the XPlatform static method:</div><div id="ww3_21_12_11_12_3_4_20" class="Preformatted">CacheManager cacheManager = XPlatform::createCacheManager(config);</div><div id="ww3_21_12_11_12_3_6_2" class="Section_Title">Shutting the connection down</div><div id="ww3_21_12_11_12_3_6_4" class="Body">The CacheManager needs to be closed in order for it to release all resources (like connections). Close it by invoking the destructor:</div><div id="ww3_21_12_11_12_3_6_6" class="Preformatted">delete cacheManager;</div><div id="ww3_21_12_11_12_3_8_2" class="Section_Title">Accessing a Cache</div><div id="ww3_21_12_11_12_3_8_4" class="Body">Once you've obtained a reference to your CacheManager, it is now connected to your CL Connector and will let you access any Cache known by the CL Connector.</div><div id="ww3_21_12_11_12_3_8_6" class="Body">To retrieve a thread-safe instance of a Cache, you will need its name, the type of the key, the value, and a serializer for those types.</div><div id="ww3_21_12_11_12_3_8_7" class="Section_Division">Serializers</div><div id="ww3_21_12_11_12_3_8_7_2" class="Body">The protocol recognizes the following types:</div><div id="ww3_21_12_11_12_3_8_7_4_2_2" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="bullet.gif" alt="*" border="0" width="10" height="10"></span></span>bool: A boolean value (true or false), one byte</div><div id="ww3_21_12_11_12_3_8_7_4_2_4" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="bullet.gif" alt="*" border="0" width="10" height="10"></span></span>byte: A signed byte</div><div id="ww3_21_12_11_12_3_8_7_4_2_6" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="bullet.gif" alt="*" border="0" width="10" height="10"></span></span>int: An 8-bit signed integer</div><div id="ww3_21_12_11_12_3_8_7_4_2_8" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="bullet.gif" alt="*" border="0" width="10" height="10"></span></span>i16: A 16-bit signed integer</div><div id="ww3_21_12_11_12_3_8_7_4_2_10" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="bullet.gif" alt="*" border="0" width="10" height="10"></span></span>i32: A 32-bit signed integer</div><div id="ww3_21_12_11_12_3_8_7_4_2_12" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="bullet.gif" alt="*" border="0" width="10" height="10"></span></span>i64: A 64-bit signed integer</div><div id="ww3_21_12_11_12_3_8_7_4_2_14" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="bullet.gif" alt="*" border="0" width="10" height="10"></span></span>double: A 64-bit floating point number</div><div id="ww3_21_12_11_12_3_8_7_4_2_16" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="bullet.gif" alt="*" border="0" width="10" height="10"></span></span>byte[]: An array of bytes</div><div id="ww3_21_12_11_12_3_8_7_4_2_18" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="bullet.gif" alt="*" border="0" width="10" height="10"></span></span>string: Encoding agnostic text or binary string</div><div id="ww3_21_12_11_12_3_8_7_6" class="Body">If you want to send complex types to the CL Connector, you will have to provide a serializer that can serialize your complex key and value types for a Cache.</div><div id="ww3_21_12_11_12_3_8_7_8" class="Body">Say we have the following Class, which is our Value type:</div><div id="ww3_21_12_11_12_3_8_7_10" class="Preformatted">class User{<br>private: long Id;<br>    std::string Login;<br>    std::string Email;<br>                   <br>public:  int getID() { return Id; }<br>                    void setID(int id) { Id = id; }<br>                    string getEmail() { return Email; }<br>                    void setEmail(int email) { Email = email; }<br>                    string getLogin() { return Login; }<br>                    void setLogin(string name) { Login = name; }<br>};</div><div id="ww3_21_12_11_12_3_8_7_12" class="Body">We store these keyed to the login, as a string. We now need to provide a serializer like this:</div><div id="ww3_21_12_11_12_3_8_7_14" class="Preformatted">class UserCacheSerializer : public CacheSerializer&lt;std::string, User&gt;<br> {<br><br>    ValueObject serializeKey(std::string &amp;deserializedKey)<br>    {<br>        return ValueObject::stringValue(deserializedKey);<br>    }<br><br>    std::string deserializeKey(ValueObject &amp;serializedKey)<br>    {<br>        return serializedKey.getString();<br>    }<br><br>    CacheValue serializeValue(User objectValue)<br>    {<br>        std::map&lt;std::string, ValueObject&gt; nvpairs;<br><br>        nvpairs["id"] = ValueObject::int8Value(objectValue.Id);<br>        nvpairs["email"] = ValueObject::stringValue(objectValue.Email);<br><br>        CacheValue value = CacheValue();<br>        value.Value = ValueObject::stringValue(objectValue.Login);<br>        value.setNvPairs(nvpairs);<br>        return value;<br>    }<br><br>    User deserializeValue(CacheValue serializedValue)<br>    {<br>        User user;<br>        user.Login = serializedValue.getValue().getString();<br>        user.Id = serializedValue.getNvPairs()["id"].getInt8();<br>        user.Email = serializedValue.serializedValue.getNvPairs()["email"].getString();<br>        return user;<br>    }<br>}</div><div id="ww3_21_12_11_12_3_8_7_16" class="Body">Note that both serialize and deserialize methods (whether for key or value) are kept symmetric.</div><div id="ww3_21_12_11_12_3_8_7_18" class="Body">CacheValue is composed of the actual ValueObject (in this example, the string representation of the user's login). CacheValue can hold entire object graphs serialized with whatever serialization strategies fits your needs. It also holds an arbitrary amount of name/value pairs. The names are std::string, while the values are of type ValueObject. You can use these name-value pairs to store whatever you want. Note that these name-value pairs also become indexable and searchable using the search API.</div><div id="ww3_21_12_11_12_3_8_7_20" class="Body">A byte array is not indexable, however it can be used within name-value pairs. In the above example, both user id and email are stored as byte arrays. Even though byte arrays are not indexable, search can be enabled on the attributes. Since we use the login as the key in our use case, storing that as a binary representation within the "default unindexed value" is good enough.</div><div id="ww3_21_12_11_12_3_8_7_22" class="Body">Note: The RawCache class, available directly from the CacheManager, allows you to access raw data, i.e., ValueObject as keys, and CacheValue as values. RawCache can be used when your data does not need to be serialized, and it allows you to create a cache without a serializer.</div><div id="ww3_21_12_11_12_3_8_8" class="Section_Division">Key-based store and retrieve</div><div id="ww3_21_12_11_12_3_8_8_2" class="Body">Now that we have defined a CacheSerializer for our cache, we can retrieve the cache from the CacheManager. The example below assumes that we have defined a cache named "userCache" within the <span class="filepath">ehcache.xml</span> file used to configure the CL Connector.</div><div id="ww3_21_12_11_12_3_8_8_4" class="Preformatted">// create a serializer<br>CacheSerializer&lt;string, User&gt; *serializer = new userCacheSerializer();<br><br>// get a cache <br>Cache&lt;string, User&gt; users = cacheManager-&gt;getCache("userCache", *serializer);<br><br>// make a user<br>User user1;<br>user1.Id = 1;<br>user1.Email = "someone@somewhere";<br>user1.Login = "secretpasswd";<br><br>// put the user<br>users-&gt;put(user1.Login, user1, type);</div><div id="ww3_21_12_11_12_3_8_8_6" class="Body">The following is an example for the Recipe code sample (example03). <span class="apiname">Recipe</span> is the class defining the domain object, and <span class="apiname">RecipeProtoBufSerializer()</span> is the serializer class.</div><div id="ww3_21_12_11_12_3_8_8_8" class="Preformatted">Cache&lt;string, Recipe&gt; *cache = cacheManager-&gt;getCache("TestCache", <br>    new RecipeProtoBufSerializer());<br>cache-&gt;put(rec.Name, rec, type);</div><div id="ww3_21_12_11_12_3_8_8_10" class="Body">The <span class="parmname">type</span> attribute calls the consistency, configured as either strong or eventual, with which you expect the CL Connector to execute the operation. For more information, refer to <span class="xref"><a href="../bigmemory-max-webhelp/co-cpp_consistency.html#wwconnect_header" title="Consistency">Consistency</a></span>.</div><div id="ww3_21_12_11_12_3_8_8_12" class="Body">To retrieve by key, invoke the get method:</div><div id="ww3_21_12_11_12_3_8_8_14" class="Preformatted">User someUser = userCache-&gt;get(someLogin, type);</div><div id="ww3_21_12_11_12_3_8_8_16" class="Body">An example of retrieving, using the Recipe demo:</div><div id="ww3_21_12_11_12_3_8_8_18" class="Preformatted">Recipe rec = (Recipe)cache-&gt;get(args[1], type);</div><div id="ww3_21_12_11_12_3_10_2" class="Section_Title">Compare and Swap (CAS) Operations</div><div id="ww3_21_12_11_12_3_10_4" class="Body">The following CAS operations are provided in C++:</div><div id="ww3_21_12_11_12_3_10_6_2_2" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="bullet.gif" alt="*" border="0" width="10" height="10"></span></span><span class="apiname">putIfAbsent(key_type_ref key, value_type_ref cacheValue)</span> - Puts the specified key/value pair into the cache only if the key has no currently assigned value. Unlike put, which can replace an existing key/value pair, putIfAbsent creates the key/value pair only if it is not present in the cache.</div><div id="ww3_21_12_11_12_3_10_6_2_4" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="bullet.gif" alt="*" border="0" width="10" height="10"></span></span><span class="apiname">remove(key_type_ref key, value_type_ref value)</span> - Conditionally removes the specified key, if it is mapped to the specified value.</div><div id="ww3_21_12_11_12_3_10_6_2_6" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="bullet.gif" alt="*" border="0" width="10" height="10"></span></span><span class="apiname">replace(key_type_ref key, value_type_ref value)</span> - Maps the specified key to the specified value, if the key is currently mapped to some value.</div><div id="ww3_21_12_11_12_3_10_6_2_8" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="bullet.gif" alt="*" border="0" width="10" height="10"></span></span><span class="apiname">replace(key_type_ref key, value_type_ref oldValue, value_type_ref newValue)</span> - Conditionally replaces the specified key's old value with the new value, if the currently existing value matches the old value.</div><div id="ww3_21_12_11_12_3_10_8" class="Body">For more information about atomic operations and cache consistency, refer to <span class="heading-page"><a href="../bigmemory-max-webhelp/co-cpp_consistency.html#wwconnect_header" title="Consistency">Consistency</a></span>.</div><div id="ww3_21_12_11_12_3_12_2" class="Section_Title">Search</div><div id="ww3_21_12_11_12_3_12_4" class="Body">This section provides an overview of how to do cross-language searches of PNF data stored within BigMemory. More detailed information may be found in "Searching a Cache" in the <span class="Citation">BigMemory Max Developer Guide</span>.</div><div id="ww3_21_12_11_12_3_12_6" class="Body">In order to search BigMemory data, you first need to add the <span class="codeph">&lt;searchable/&gt;</span> tag to the cache configuration in your <span class="filepath">ehcache.xml</span> file.</div><div id="ww3_21_12_11_12_3_12_8" class="Preformatted">&lt;ehcache&gt;<br>(...)<br>  &lt;cache name="userCache"&gt;<br>  (...)<br>    &lt;searchable/&gt;<br>  &lt;/cache&gt;<br>&lt;/ehcache&gt;</div><div id="ww3_21_12_11_12_3_12_10" class="Body">This configuration will scan all keys and values in the cache and, if they are of supported search types, add them as search attributes. Values of the Name/Value pairs in the PNF's ValueObject sent to the CL Connector, other than of type byte[], can all be indexed and made searchable. (Continuing with the example of the previous section, this would mean <span class="codeph">id</span> and<span class="codeph"> email</span>.)</div><div id="ww3_21_12_11_12_3_12_12" class="Body">You can also add search attributes using the provided attributeExtractor class, for example:</div><div id="ww3_21_12_11_12_3_12_14" class="Preformatted">&lt;ehcache&gt;<br>(...)<br>  &lt;cache name="userCache"&gt;<br>  (...)<br>    &lt;searchable&gt;<br>      &lt;searchAttribute name="email" class="net.sf.ehcache.xplatform.search.Indexer"/&gt;<br>    &lt;/searchable&gt;<br>  &lt;/cache&gt;<br>&lt;/ehcache&gt;</div><div id="ww3_21_12_11_12_3_12_16" class="Body">To perform a query, use the Cache.query(String) method, providing a BigMemory SQL query string, for example:</div><div id="ww3_21_12_11_12_3_12_18" class="Preformatted">SearchResults&lt;string, User&gt; result = userCache-&gt;query("select * from userCache <br>    where email ilike '%@terracottatech.com'");</div><div id="ww3_21_12_11_12_3_12_20" class="Body">For more information about how to construct BigMemory SQL queries, see "Searching with BigMemory SQL" in the <span class="Citation">BigMemory Max Developer Guide</span>.</div><div id="ww3_21_12_11_12_3_12_22" class="Body">Note: Java (POJO) data stored within BigMemory can also be searched using the native Ehcache Search API, which is documented in the <span class="Citation">BigMemory Max Developer Guide</span>.</div><footer><!-- Related Topics --><!--                --><!-- Back to Top --><!--             --><!-- Disqus --><!--        --><!-- Google Translation --><!--                    --><br></footer><div><div style="font-family: Arial, Verdana, Helvetica, Sans-Serif; font-size: 11px; margin-top: 20px; margin-bottom: 20px;"><span class="xref"><a href="http://documentation.softwareag.com/legal/" target="external_window">Copyright © <span>2010</span><span>-2016</span><span></span><span></span> Software AG, Darmstadt, Germany</a></span>.</div><hr></div><div style="font-family: Arial, Verdana, Helvetica, Sans-Serif; font-size: 13px; font-weight: bold; margin-top: 20px;"><span><img style="vertical-align:middle" src="../connect/terracotta_online.png" alt="Product Logo"><a href="https://empower.softwareag.com/ContactSupport/default.asp" target="_blank">Contact&nbsp;Support</a>
         &nbsp;&nbsp;|&nbsp;&nbsp;
       <a href="http://www.softwareag.com/corporate/community/default.asp" target="_blank">Community</a>
         &nbsp;&nbsp;|&nbsp;&nbsp;
       <a href="mailto://documentation@softwareag.com" target="_blank">Feedback&nbsp;&nbsp;</a></span></div></body></html>