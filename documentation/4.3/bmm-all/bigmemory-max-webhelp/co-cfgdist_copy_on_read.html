<!DOCTYPE html ><html xml:lang="en" lang="en" xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta http-equiv="Content-Style-Type" content="text/css"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Copy On Read</title><link rel="Prev" href="co-cfgdist_cache_events_configuration.html" title="Previous"><link rel="Next" href="co-cfgdist_consistency_modes.html" title="Next"><link rel="StyleSheet" href="css/aaa_bigmem_max_all.css" type="text/css" media="all"><link rel="StyleSheet" href="css/skin.css" type="text/css" media="all"><link rel="StyleSheet" href="css/social.css" type="text/css" media="all"><link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all"><!--[if IE 7]><link rel="StyleSheet" href="css/aaa_bigmem_max_all_IE7.css" type="text/css" media="all"><![endif]--><link rel="StyleSheet" href="css/print.css" type="text/css" media="print"><script type="text/javascript">
    'use strict';

    var redirect_url, page_hash;

    if (window === window.top) {
        // Redirect
        //
        redirect_url = "../index.html#page/bigmemory-max-webhelp/co-cfgdist_copy_on_read.html";
        if (window.document.location.hash.length > 1) {
            // Sanitize and append it
            //
            page_hash = window.document.location.hash.substring(1);
            page_hash = page_hash.replace(/[\\><:;"]|%5C|%3C|%3E|%3A|%3B|%22/gi, '');
            redirect_url += '#' + page_hash;
        }
        window.document.location.replace(redirect_url);
    }
</script><script type="text/javascript" src="scripts/common.js"></script><script type="text/javascript" src="scripts/page.js"></script><script type="text/javascript" src="scripts/search-client.js"></script><script type="text/javascript" src="scripts/unidata.js"></script><script type="text/javascript" src="scripts/unibreak.js"></script></head><body id="pzs6x9u8sfcHpRjZ42LNdFQ" class="ww_skin_page_body" onload="Page.OnLoad('../index.html#page/bigmemory-max-webhelp/co-cfgdist_copy_on_read.html');"><header id="wwconnect_header"><div class="ww_skin_breadcrumbs"><span class="ww_skin_breadcrumbs_parent"><a href="../bigmemory-max-webhelp/to-title_product_documentation.html#wwconnect_header">Product Documentation</a></span><span class="ww_skin_breadcrumbs_divider"> : </span><span class="ww_skin_breadcrumbs_parent"><a href="../bigmemory-max-webhelp/to-title_bigmemory_max_config_guide.html#wwconnect_header">BigMemory Max Configuration Guide</a></span><span class="ww_skin_breadcrumbs_divider"> : </span><span class="ww_skin_breadcrumbs_parent"><a href="../bigmemory-max-webhelp/to-cfgdist_defining_distributed_configurations.html#wwconnect_header">Defining a Distributed Configuration</a></span><span class="ww_skin_breadcrumbs_divider"> : </span><span class="ww_skin_breadcrumbs_current">Copy On Read</span></div><div class="ww_skin_page_toolbar"></div></header><div id="ww3_17_10_17_18_1" class="Heading_3">Copy On Read</div><div id="ww3_17_10_17_18_3_2" class="Body">The <span class="codeph">copyOnRead</span> setting is most easily explained by first examining what it does when not enabled and exploring the potential problems that can arise. For a cache in which <span class="codeph">copyOnRead</span> is not enabled, the following reference comparison will always be true:</div><div id="ww3_17_10_17_18_3_4" class="Preformatted">Object obj1 = c.get("key").getValue(); <br>// Assume no other thread changes the cache mapping between these get() operations .... <br>Object obj2 = c.get("key").getValue(); <br>if (obj1 == obj2) { <br> System.err.println("Same value objects!"); <br>}</div><div id="ww3_17_10_17_18_3_6" class="Body">The fact that the same object reference is returned across multiple get() operations implies that the cache is storing a direct reference to cache value. This default behavior (copyOnRead=false) is usually desired, although there are at least two scenarios in which it is problematic:</div><div id="ww3_17_10_17_18_3_8_2" class="Numbered_1"><span class="WebWorks_Number" style="width: 18pt"><span>1. </span></span>Caches shared between classloaders</div><div id="ww3_17_10_17_18_3_8_2_3" class="Numbered_1_Continued">and</div><div id="ww3_17_10_17_18_3_8_4" class="Numbered_1"><span class="WebWorks_Number" style="width: 18pt"><span>2. </span></span>Mutable value objects</div><div id="ww3_17_10_17_18_3_10" class="Body">Imagine two web applications that both have access to the same Cache instance (this implies that the core Ehcache classes are in a common classloader). Imagine further that the classes for value types in the cache are duplicated in the web application (so they are not present in the common loader). In this scenario you would get ClassCastExceptions when one web application accessed a value previously read by the other application.</div><div id="ww3_17_10_17_18_3_12" class="Body">One obvious solution to this problem is to move the value types to the common loader, but another is to enable <span class="codeph">copyOnRead</span>. When copyOnRead is in effect, the object references are unique with every get(). Having unique object references means that the thread context loader of the caller will be used to materialize the cache values on each get(). This feature has utility in OSGi environments as well where a common cache service might be shared between bundles.</div><div id="ww3_17_10_17_18_3_14" class="Body">Another subtle issue concerns mutable value objects in a distributed cache. Consider this simple code with a Cache containing a mutable value type (Foo):</div><div id="ww3_17_10_17_18_3_16" class="Preformatted">class Foo { <br> int field; <br>} <br>Foo foo = (Foo) c.get("key").getValue(); <br>foo.field++; <br>// foo instance is never re-put() to the cache <br>// ...</div><div id="ww3_17_10_17_18_3_18" class="Body">If the Foo instance is never put back into the Cache your local cache is no longer consistent with the cluster (it is locally modified only). Enabling <span class="codeph">copyOnRead</span> eliminates this possibility since the only way to affect cache values is to call mutator methods on the Cache.</div><div id="ww3_17_10_17_18_3_20" class="Body">It is worth noting that there is a performance penalty to copyOnRead since values are deserialized on every get().</div><footer><!-- Related Topics --><!--                --><!-- Back to Top --><!--             --><!-- Disqus --><!--        --><!-- Google Translation --><!--                    --><br></footer><div><div style="font-family: Arial, Verdana, Helvetica, Sans-Serif; font-size: 11px; margin-top: 20px; margin-bottom: 20px;"><span class="xref"><a href="http://documentation.softwareag.com/legal/" target="external_window">Copyright Â© <span>2010</span><span>-2016</span><span></span><span></span> Software AG, Darmstadt, Germany</a></span>.</div><hr></div><div style="font-family: Arial, Verdana, Helvetica, Sans-Serif; font-size: 13px; font-weight: bold; margin-top: 20px;"><span><img style="vertical-align:middle" src="../connect/terracotta_online.png" alt="Product Logo"><a href="https://empower.softwareag.com/ContactSupport/default.asp" target="_blank">Contact&nbsp;Support</a>
         &nbsp;&nbsp;|&nbsp;&nbsp;
       <a href="http://www.softwareag.com/corporate/community/default.asp" target="_blank">Community</a>
         &nbsp;&nbsp;|&nbsp;&nbsp;
       <a href="mailto://documentation@softwareag.com" target="_blank">Feedback&nbsp;&nbsp;</a></span></div></body></html>