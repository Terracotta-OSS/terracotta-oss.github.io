<!DOCTYPE html ><html xml:lang="en" lang="en" xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta http-equiv="Content-Style-Type" content="text/css"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Jobs and JobDetails</title><link rel="Prev" href="co-use_jobs_and_triggers.html" title="Previous"><link rel="Next" href="to-trg_working_with_triggers.html" title="Next"><link rel="StyleSheet" href="css/_qs_all.css" type="text/css" media="all"><link rel="StyleSheet" href="css/skin.css" type="text/css" media="all"><link rel="StyleSheet" href="css/social.css" type="text/css" media="all"><link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all"><!--[if IE 7]><link rel="StyleSheet" href="css/_qs_all_IE7.css" type="text/css" media="all"><![endif]--><link rel="StyleSheet" href="css/print.css" type="text/css" media="print"><script type="text/javascript">
    'use strict';

    var redirect_url, page_hash;

    if (window === window.top) {
        // Redirect
        //
        redirect_url = "../index.html#page/quartz-scheduler-webhelp/co-job_and_job_details.html";
        if (window.document.location.hash.length > 1) {
            // Sanitize and append it
            //
            page_hash = window.document.location.hash.substring(1);
            page_hash = page_hash.replace(/[\\><:;"]|%5C|%3C|%3E|%3A|%3B|%22/gi, '');
            redirect_url += '#' + page_hash;
        }
        window.document.location.replace(redirect_url);
    }
</script><script type="text/javascript" src="scripts/common.js"></script><script type="text/javascript" src="scripts/page.js"></script><script type="text/javascript" src="scripts/search-client.js"></script><script type="text/javascript" src="scripts/unidata.js"></script><script type="text/javascript" src="scripts/unibreak.js"></script></head><body id="pqL1hwmykI3erNnvCc0eA6Q" class="ww_skin_page_body" onload="Page.OnLoad('../index.html#page/quartz-scheduler-webhelp/co-job_and_job_details.html');"><header id="wwconnect_header"><div class="ww_skin_breadcrumbs"><span class="ww_skin_breadcrumbs_parent"><a href="../quartz-scheduler-webhelp/_qs_all.1.009.html#wwconnect_header">Quartz Scheduler Developer Guide</a></span><span class="ww_skin_breadcrumbs_divider"> : </span><span class="ww_skin_breadcrumbs_current">Jobs and JobDetails</span></div><div class="ww_skin_page_toolbar"></div></header><div id="ww3_9_9_1" class="Heading_1">Jobs and JobDetails</div><div id="ww3_9_9_3_2" class="Body">Jobs are easy to implement, having just a single 'execute' method in the interface. There are just a few more things that you need to understand about the nature of jobs, about the execute(..) method of the Job interface, and about JobDetails.</div><div id="ww3_9_9_3_4" class="Body">While a job class that you implement has the code that knows how do the actual work of the particular type of job, Quartz needs to be informed about various attributes that you may wish an instance of that job to have. This is done via the JobDetail class, which was mentioned briefly in the previous section.</div><div id="ww3_9_9_3_6" class="Body">JobDetail instances are built using the JobBuilder class. You will typically want to use a static import of all of its methods, in order to have the DSL-feel within your code.</div><div id="ww3_9_9_3_8" class="Preformatted">import static org.quartz.JobBuilder.*;</div><div id="ww3_9_9_3_10" class="Body">The following code snippet defines a job and schedules it for execution:</div><div id="ww3_9_9_3_12" class="Preformatted">  // define the job and tie it to our HelloJob class      <br>  JobDetail job = newJob(HelloJob.class)      <br>      .withIdentity("myJob", "group1") // name "myJob", group "group1"      <br>      .build();      <br>              <br>  // Trigger the job to run now, and then every 40 seconds      <br>  Trigger trigger = newTrigger()      <br>      .withIdentity("myTrigger", "group1")      <br>      .startNow()      <br>      .withSchedule(simpleSchedule()      <br>          .withIntervalInSeconds(40)      <br>          .repeatForever())                  <br>      .build();      <br>              <br>  // Tell quartz to schedule the job using our trigger      <br>  sched.scheduleJob(job, trigger);</div><div id="ww3_9_9_3_14" class="Body">Now consider the job class HelloJob shown below:</div><div id="ww3_9_9_3_16" class="Preformatted">  public class HelloJob implements Job {      <br>    public HelloJob() {      <br>    }      <br>    public void execute(JobExecutionContext context)      <br>      throws JobExecutionException      <br>    {      <br>      System.err.println("Hello!  HelloJob is executing.");      <br>    }      <br>  }</div><div id="ww3_9_9_3_18" class="Body">Notice that we give the scheduler a JobDetail instance, and that it knows the type of job to be executed by simply providing the job's class as we build the JobDetail. Each (and every) time the scheduler executes the job, it creates a new instance of the class before calling its execute(..) method. When the execution is complete, references to the job class instance are dropped, and the instance is then garbage collected.</div><div id="ww3_9_9_3_20" class="Body">One of the ramifications of this behavior is the fact that jobs must have a no-argument constructor (when using the default JobFactory implementation). Another ramification is that it does not make sense to have state data-fields defined on the job class - as their values would not be preserved between job executions.</div><div id="ww3_9_9_3_22" class="Body">To provide properties/configuration for a Job instance or keep track of a job's state between executions, you use the JobDataMap, which is part of the JobDetail object.</div><div id="ww3_9_9_3_24_2" class="Section_Title">JobDataMap</div><div id="ww3_9_9_3_24_4" class="Body">The JobDataMap can be used to hold any amount of (serializable) data objects which you wish to have made available to the job instance when it executes. JobDataMap is an implementation of the Java Map interface, and has some added convenience methods for storing and retrieving data of primitive types.</div><div id="ww3_9_9_3_24_6" class="Body">Here's some snippets of putting data into the JobDataMap while defining/building the JobDetail, prior to adding the job to the scheduler:</div><div id="ww3_9_9_3_24_8" class="Preformatted">  // define the job and tie it to our DumbJob class      <br>  JobDetail job = newJob(DumbJob.class)      <br>      .withIdentity("myJob", "group1") // name "myJob", group "group1"      <br>      .usingJobData("jobSays", "Hello World!")      <br>      .usingJobData("myFloatValue", 3.141f)      <br>      .build();</div><div id="ww3_9_9_3_24_10" class="Body">Here is an example of getting data from the JobDataMap during the job's execution:</div><div id="ww3_9_9_3_24_12" class="Preformatted">public class DumbJob implements Job {      <br>    public DumbJob() {      <br>    }      <br>    public void execute(JobExecutionContext context)      <br>      throws JobExecutionException      <br>    {      <br>      JobKey key = context.getJobDetail().getKey();      <br>      JobDataMap dataMap = context.getJobDetail().getJobDataMap();      <br>      String jobSays = dataMap.getString("jobSays");      <br>      float myFloatValue = dataMap.getFloat("myFloatValue");      <br>      System.err.println("Instance " + key + " of DumbJob says: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ jobSays + ", and val is: " + myFloatValue);      <br>    }      <br>  }</div><div id="ww3_9_9_3_24_14" class="Body">If you use a persistent JobStore (discussed in the JobStore section of this tutorial) you should use some care in deciding what you place in the JobDataMap, because the object in it will be serialized, and they therefore become prone to class-versioning problems. Obviously standard Java types should be very safe, but beyond that, any time someone changes the definition of a class for which you have serialized instances, care has to be taken not to break compatibility. Optionally, you can put JDBC-JobStore and JobDataMap into a mode where only primitives and strings are allowed to be stored in the map, thus eliminating any possibility of later serialization problems.</div><div id="ww3_9_9_3_24_16" class="Body">If you add setter methods to your job class that correspond to the names of keys in the JobDataMap (such as a setJobSays(String val) method for the data in the example above), then Quartz's default JobFactory implementation will automatically call those setters when the job is instantiated, thus preventing the need to explicitly get the values out of the map within your execute method.</div><div id="ww3_9_9_3_24_18" class="Body">Triggers can also have JobDataMaps associated with them. This can be useful in the case where you have a Job that is stored in the scheduler for regular/repeated use by multiple Triggers, yet with each independent triggering, you want to supply the Job with different data inputs.</div><div id="ww3_9_9_3_24_20" class="Body">The JobDataMap that is found on the JobExecutionContext during Job execution serves as a convenience. It is a merge of the JobDataMap found on the JobDetail and the one found on the Trigger, with the values in the latter overriding any same-named values in the former.</div><div id="ww3_9_9_3_24_22" class="Body">Here's a quick example of getting data from the JobExecutionContextâ€™s merged JobDataMap during the job's execution:</div><div id="ww3_9_9_3_24_24" class="Preformatted">public class DumbJob implements Job {      <br>    public DumbJob() {      <br>    }      <br>    public void execute(JobExecutionContext context)      <br>      throws JobExecutionException      <br>    {      <br>      JobKey key = context.getJobDetail().getKey();      <br>      JobDataMap dataMap = context.getMergedJobDataMap(); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Note the difference from the previous example      <br>      String jobSays = dataMap.getString("jobSays");      <br>      float myFloatValue = dataMap.getFloat("myFloatValue");      <br>      ArrayList state = (ArrayList)dataMap.get("myStateData");      <br>      state.add(new Date());      <br>      System.err.println("Instance " + key + " of DumbJob says: " + jobSays <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ ", and val is: " + myFloatValue);      <br>    }      <br>  }</div><div id="ww3_9_9_3_24_26" class="Body">Or if you wish to rely on the JobFactory injecting the data map values onto your class, it might look like this instead:</div><div id="ww3_9_9_3_24_28" class="Preformatted">public class DumbJob implements Job {      <br>    String jobSays;      <br>    float myFloatValue;      <br>    ArrayList state;      <br>            <br>    public DumbJob() {      <br>    }      <br>    public void execute(JobExecutionContext context)      <br>      throws JobExecutionException      <br>    {      <br>      JobKey key = context.getJobDetail().getKey();      <br>      JobDataMap dataMap = context.getMergedJobDataMap(); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Note the difference from the previous example      <br>      state.add(new Date());      <br>      System.err.println("Instance " + key + " of DumbJob says: " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ jobSays + ", and val is: " + myFloatValue);      <br>    }      <br>          <br>    public void setJobSays(String jobSays) {      <br>      this.jobSays = jobSays;      <br>    }      <br>          <br>    public void setMyFloatValue(float myFloatValue) {      <br>      myFloatValue = myFloatValue;      <br>    }      <br>          <br>    public void setState(ArrayList state) {      <br>      state = state;      <br>    }      <br>          <br>  }</div><div id="ww3_9_9_3_24_30" class="Body">You'll notice that the overall code of the class is longer, but the code in the execute() method is cleaner. One could also argue that although the code is longer, that it actually took less coding, if the programmer's IDE was used to auto-generate the setter methods, rather than having to hand-code the individual calls to retrieve the values from the JobDataMap. The choice is yours.</div><div id="ww3_9_9_3_26_2" class="Section_Title">Job Instances</div><div id="ww3_9_9_3_26_4" class="Body">You can create a single job class, and store many 'instance definitions' of it within the scheduler by creating multiple instances of JobDetails - each with its own set of properties and JobDataMap - and adding them all to the scheduler.</div><div id="ww3_9_9_3_26_6" class="Body">For example, you can create a class that implements the Job interface called SalesReportJob. The job might be coded to expect parameters sent to it (via the JobDataMap) to specify the name of the sales person that the sales report should be based on. They may then create multiple definitions (JobDetails) of the job, such as SalesReportForJoe and SalesReportForMike which have "joe" and "mike" specified in the corresponding JobDataMaps as input to the respective jobs.</div><div id="ww3_9_9_3_26_8" class="Body">When a trigger fires, the JobDetail (instance definition) it is associated to is loaded, and the job class it refers to is instantiated via the JobFactory configured on the Scheduler. The default JobFactory simply calls newInstance() on the job class, then attempts to call setter methods on the class that match the names of keys within the JobDataMap. You may want to create your own implementation of JobFactory to accomplish things such as having your application's IoC or DI container produce/initialize the job instance.</div><div id="ww3_9_9_3_26_10" class="Body">Each stored JobDetail is referred to as a <span class="emphasis">job definition</span> or <span class="emphasis">JobDetail instance</span>, and each executing job is a <span class="emphasis">job instance</span> or <span class="emphasis">instance of a job definition</span>. In general, when the term "job" is used, it refers to a named definition, or JobDetail. The class implementing the job interface, is called the "job class."</div><div id="ww3_9_9_3_28_2" class="Section_Title">Job State and Concurrency</div><div id="ww3_9_9_3_28_4" class="Body">The following are additional notes about a job's state data (aka JobDataMap) and concurrency. There are a couple annotations that you can add to your Job class that affect Quartz's behavior with respect to these aspects.</div><div id="ww3_9_9_3_28_6" class="Body">@DisallowConcurrentExecution is an annotation that can be added to the Job class that tells Quartz not to execute multiple instances of a given job definition (that refers to the given job class) concurrently. In the example from the previous section, if SalesReportJob has this annotation, than only one instance of SalesReportForJoe can execute at a given time, but it <span class="emphasis">can</span> execute concurrently with an instance of "SalesReportForMike". The constraint is based upon an instance definition (JobDetail), not on instances of the job class. However, it was decided (during the design of Quartz) to have the annotation carried on the class itself, because it does often make a difference to how the class is coded.</div><div id="ww3_9_9_3_28_8" class="Body">@PersistJobDataAfterExecution is an annotation that can be added to the Job class that tells Quartz to update the stored copy of the JobDetailâ€™s JobDataMap after the execute() method completes successfully (without throwing an exception), such that the next execution of the same job (JobDetail) receives the updated values rather than the originally stored values. Like the @DisallowConcurrentExecution annotation, this applies to a job definition instance, not a job class instance, though it was decided to have the job class carry the attribute because it does often make a difference to how the class is coded (e.g. the "statefulness" will need to be explicitly understood by the code within the execute method).</div><div id="ww3_9_9_3_28_10" class="Body">If you use the @PersistJobDataAfterExecution annotation, you should strongly consider also using the @DisallowConcurrentExecution annotation, in order to avoid possible confusion (race conditions) of what data was left stored when two instances of the same job (JobDetail) executed concurrently.</div><div id="ww3_9_9_3_30_2" class="Section_Title">Other Attributes Of Jobs</div><div id="ww3_9_9_3_30_4" class="Body">Here's a quick summary of the other properties you can define for a job instance via the JobDetail object:</div><div id="ww3_9_9_3_30_6_2" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="bullet.gif" alt="*" border="0" width="10" height="10"></span></span>Durability - if a job is non-durable, it is automatically deleted from the scheduler once there are no longer any active triggers associated with it. In other words, non-durable jobs have a life span bounded by the existence of its triggers.</div><div id="ww3_9_9_3_30_6_4" class="List_1"><span class="WebWorks_Number" style="width: 18pt"><span><img src="bullet.gif" alt="*" border="0" width="10" height="10"></span></span>RequestsRecovery - if a job "requests recovery" and it is executing during the time of a hard shutdown of the scheduler (i.e. the process it is running within crashes, or the machine is shut off), then it is re-executed when the scheduler is started again. In this case, the JobExecutionContext.isRecovering() method will return true.</div><div id="ww3_9_9_3_32_2" class="Section_Title">JobExecutionException</div><div id="ww3_9_9_3_32_4" class="Body">Finally, we need to inform you of a few details of the <span class="codeph">Job.execute(..)</span> method. The only type of exception (including RuntimeExceptions) that you are allowed to throw from the execute method is the JobExecutionException. Because of this, you should generally wrap the entire contents of the execute method with a 'try-catch' block. You should also spend some time looking at the documentation for the JobExecutionException, as your job can use it to provide the scheduler various directives as to how you want the exception to be handled.</div><footer><!-- Related Topics --><!--                --><!-- Back to Top --><!--             --><!-- Disqus --><!--        --><!-- Google Translation --><!--                    --><br></footer><div><div style="font-family: Arial, Verdana, Helvetica, Sans-Serif; font-size: 11px; margin-top: 20px; margin-bottom: 20px;"><span class="xref"><a href="http://documentation.softwareag.com/legal/" target="external_window">Copyright Â© <span>2010</span><span>-2016</span><span></span><span></span> Software AG, Darmstadt, Germany</a></span>.</div><hr></div><div style="font-family: Arial, Verdana, Helvetica, Sans-Serif; font-size: 13px; font-weight: bold; margin-top: 20px;"><span><img style="vertical-align:middle" src="../connect/quartz_online.png" alt="Product Logo"><!--	     <a href="https://empower.softwareag.com/ContactSupport/default.asp" target="_blank" >Contact&#160;Support</a> --><!--         &#160;&#160;|&#160;&#160;  --><!--         <a href="http://www.softwareag.com/corporate/community/default.asp" target="_blank" >Community</a>  --><!--         &#160;&#160;  -->
          |&nbsp;&nbsp;
        <a href="mailto://documentation@softwareag.com" target="_blank">Feedback&nbsp;&nbsp;</a></span></div></body></html>